/**
 * Given sequence k = k1<; k2<..... kn of n sorted keys, with a search probability pi for each key ki . Build the Binary search tree that has the least search cost given the access probability for each key.
 * test your program for following example
 * p1 = 10,p2 = 3, p3 = 9, p4 = 2, p5 = 0, p6 = 10;
 * q0 = 5, q1 = 6, q2 = 4, q3= 4, q4 = 3, q5 = 8, q6 = 0
 *
 * */
#include "bits/stdc++.h"
using namespace std;

int p[] = {10, 3, 9, 2, 0, 10}, q[] = {5, 6, 4, 4, 3, 8, 0};
int weight[7][7], cost[7][7], root[7][7];
int main(){
    //freopen("output.txt", "w", stdout);
    for (int i = 0; i < 7; i++)
        weight[i][i] = q[i], cost[i][i] = 0, root[i][i] = 0;
    for (int k = 1; k < 7; k++){
        cout << "Step" << k << " : \n\n";
        for (int i = 0; i < 7-k; i++){
            weight[i][i+k] = p[i+k-1] + q[i+k] + weight[i][i+k-1];
            int temp = INT_MAX, tempI = -1;
            for (int j = i+1; j < i+k+1; j++)
                if (temp > cost[i][j-1]+ cost[j][i+k] + weight[i][i+k])
                    temp = cost[i][j-1]+ cost[j][i+k] + weight[i][i+k], tempI = j;
            cost[i][i+k] = temp;
            root[i][i+k] = tempI;

            cout << "   " << i << i+k << ":: " << weight[i][i+k] << " " << cost[i][i+k] << " " << root[i][i+k] << " \n";
        }
        cout << "---------------------------------\n";
    }
    cout << cost[0][6] << "\n";
    return 0;
}